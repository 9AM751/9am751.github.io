{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"overview","text":"与掘金发的文章不同的是，这里会记录学习历程，以及更多思考 未必像参照官方文档而写下的实践笔记一样准确 开发技巧养成良好的编码习惯 微服务 Microservices 响应式编程 Spring Boot WebFlux 容器化与云原生闲暇之余的探索 docker，k8s，以及Quarkus","link":"/overview/index.html"}],"posts":[{"title":"后端标准返回格式","text":"在前后端分离项目中，我们在后端把结果封装成JSON，然后前端拿到后进行解析填充到UI组件 这个JSON的格式，必须包含的三部分 status 状态值：由后端统一定义各种返回结果的状态码 message 描述：本次接口调用的结果描述 data 数据：本次返回的数据 12345{ &quot;status&quot;:&quot;200&quot;, &quot;message&quot;:&quot;操作成功&quot;, &quot;data&quot;:&quot;fuck!&quot;} 通常我们会在Common公共模块下的utils包中编写一个ResultData工具类，然后在Controller中使用ResultData的方法来封装结果，像这样： 定义返回结果对象123456789101112131415161718192021222324252627282930@Datapublic class ResultData&lt;T&gt; { // 结果状态 ,具体状态码见ReturnCode.java private int status; private String message; private T data; private long timestamp ; //接口调用时间戳 public ResultData (){ this.timestamp = System.currentTimeMillis(); } public static &lt;T&gt; ResultData&lt;T&gt; success(T data) { ResultData&lt;T&gt; resultData = new ResultData&lt;&gt;(); resultData.setStatus(ReturnCode.RC100.getCode()); resultData.setMessage(ReturnCode.RC100.getMessage()); resultData.setData(data); return resultData; } public static &lt;T&gt; ResultData&lt;T&gt; fail(int code, String message) { ResultData&lt;T&gt; resultData = new ResultData&lt;&gt;(); resultData.setStatus(code); resultData.setMessage(message); return resultData; }} 定义状态码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public enum ReturnCode { /**操作成功**/ RC100(100,&quot;操作成功&quot;), /**操作失败**/ RC999(999,&quot;操作失败&quot;), /**服务限流**/ RC200(200,&quot;服务开启限流保护,请稍后再试!&quot;), /**服务降级**/ RC201(201,&quot;服务开启降级保护,请稍后再试!&quot;), /**热点参数限流**/ RC202(202,&quot;热点参数限流,请稍后再试!&quot;), /**系统规则不满足**/ RC203(203,&quot;系统规则不满足要求,请稍后再试!&quot;), /**授权规则不通过**/ RC204(204,&quot;授权规则不通过,请稍后再试!&quot;), /**access_denied**/ RC403(403,&quot;无访问权限,请联系管理员授予权限&quot;), /**access_denied**/ RC401(401,&quot;匿名用户访问无权限资源时的异常&quot;), /**服务异常**/ RC500(500,&quot;系统异常，请稍后重试&quot;), INVALID_TOKEN(2001,&quot;访问令牌不合法&quot;), ACCESS_DENIED(2003,&quot;没有权限访问该资源&quot;), CLIENT_AUTHENTICATION_FAILED(1001,&quot;客户端认证失败&quot;), USERNAME_OR_PASSWORD_ERROR(1002,&quot;用户名或密码错误&quot;), UNSUPPORTED_GRANT_TYPE(1003, &quot;不支持的认证模式&quot;); /**自定义状态码**/ private final int code; /**自定义描述**/ private final String message; ReturnCode(int code, String message){ this.code = code; this.message = message; } public int getCode() { return code; } public String getMessage() { return message; }} 使用统一返回格式1234@GetMapping(&quot;/fuck&quot;)public ResultData&lt;String&gt; getFuck(){ return ResultData.success(&quot;fuck!&quot;);} 结果 1234567{ &quot;status&quot;: 100, &quot;message&quot;: &quot;fuck&quot;, &quot;data&quot;: null, &quot;timestamp&quot;: 1625736481648, &quot;httpStatus&quot;: 0} 更优雅每次都要ResultData.success()包装，直到后来我看在艿艿的公众号上看到了这种做法 借助SpringBoot提供的 ResponseBodyAdvice和@RestControllerAdvice ResponseBodyAdvice的作用： 拦截Controller方法的返回值，统一处理返回值/响应体，一般用来统一返回格式，加解密，签名等等 而@RestControllerAdvice是 @RestController注解的增强，可以实现三个方面的功能 全局异常处理 全局数据绑定 全局数据预处理 编写ResponseBodyAdvice的一个具体实现类ResponseBodyAdvic.java 123456789101112131415161718192021@RestControllerAdvicepublic class ResponseAdvice implements ResponseBodyAdvice&lt;Object&gt; { @Autowired private ObjectMapper objectMapper; @Override public boolean supports(MethodParameter methodParameter, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass) { return true; }@SneakyThrows@Overridepublic Object beforeBodyWrite(Object o, MethodParameter methodParameter, MediaType mediaType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass, ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse) { if(o instanceof String){ return objectMapper.writeValueAsString(ResultData.success(o)); } if(o instanceof ResultData){ return o; } return ResultData.success(o); }} 全局异常处理器面对错误结果抛出异常时，统一处理response的结果 12345678910111213141516 @Slf4j @RestControllerAdvicepublic class RestExceptionHandler { /** * 默认全局异常处理。 * @param e the e * @return ResultData */ @ExceptionHandler(Exception.class) @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) public ResultData&lt;String&gt; exception(Exception e) { log.error(&quot;全局异常信息 ex={}&quot;, e.getMessage(), e); return ResultData.fail(ReturnCode.RC500.getCode(),e.getMessage()); }}","link":"/2022/06/16/%E5%90%8E%E7%AB%AF%E6%A0%87%E5%87%86%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F/"},{"title":"在WSL2中使用Docker快速搭建Windows开发环境","text":"每次电脑重置之后最烦的就是搭建环境，什么mysql，redis，nacos等等，（当然现在我的nacos集群已经迁移的远程服务器上了qwq），要去各种官网下载安装包或者二进制文件，安装的时候勾选一个不慎就出问题，那是相当的麻烦，大三下学期结束又一次重置之后，果断选择在WSL2中使用docker，把上述环境全部作为容器run起来 只需pull下镜像，然后运行容器即可，免去上述的问题，并且不用时可以stop容器以减少内存占用 大概思路因为我当时刚装完系统没下picgo，所以也没截图什么的，只能说下当时的流程和最后结果 WSL2 现在微软已经把WSL2作为默认的了，我记的以前使用WSL2要去下扩展然后从WSL1切换过去，但现在很方便，按照文档指示就一条命令 地址 安装 WSL | Microsoft Docs 安装好之后去微软商店里下载Linux，wsl访问Linux目录的命令是\\\\wsl$ 安装docker推荐去b站看这个，以及他这个系列的其他视频 https://www.bilibili.com/video/BV1nt4y1k7Fy?share_source=copy_web 他会手把手教你如何在wsl管理的Linux中安装docker，以及如何抛弃vim并配置vscode在windows编写，Linux编译的高效操作。 容器化部署如果你对docker的概念以及常见使用方法不熟悉，可以去看这个 https://yeasy.gitbook.io/docker_practice/ 写的非常好，是一个开源的项目，一些大佬一起维护这本Gitbook 知道如何拉取镜像，部署容器，挂载目录，操作容器等等这些基本操作就够，当然你也可以编写自己的docker file为下一次重置做准备 (=W=) 管理容器可以设置开机时docker自启，这样随着docker服务的启动，是restart=always的容器也会跟着自己start起来。 WSL2中安装docker 并开机启动 - 简书 推荐使用portainer去管理容器","link":"/2022/06/16/%E5%9C%A8WSL%E4%B8%AD%E4%BD%BF%E7%94%A8Docker%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAWindows%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/06/16/hello-world/"},{"title":"实际项目中的缓存与锁","text":"结合当项目的场景思考与分析，右侧的目录是最好的思路和大纲 这个项目的场景使用Spring Cache配合本地锁是完全够用的，需要放入缓存的数据也就千条即使走db查询性能也可以忽略不计，所以本着学习的目的来探讨分布式场景下的问题和方案。 下面的知识点，代码，方案实现并不完全来源于视频，比如精细了锁的粒度用读写锁，缓存的事务回滚如何避免出现bug，分析看门狗机制等等都是视频没有提到的。 一. 适合放入缓存的数据 及时性，对数据短暂的一致性要求不高的 访问量大且更新频率不高的数据 (读多写少) 举例： 电商类应用，商品分类，商品列表等适合缓存并加一个失效时间（根据数据更新频率来定） 后台如果发布一个商品，买家需要5分钟才能看到新的商品一般还是可以接受的 物流信息 在该项目中商城的首页分类信息(1452条)几乎是不总修改的，但是频繁读取所以适合放入缓存中 由于无法在多台服务器上搭建真正的分布式系统，所以只能创建多个实例来模拟伪分布式的情况，实际上分布式与伪分布式需要被考虑和被解决的问题是一样的。 二. 使用缓存的流程以下的使用缓存的各种方案都是基于该思路流程 三. 本地缓存的局限性前面提到使用缓存是为了提高读取速度 那么使用本地缓存可以理解为，使用一个进程里的某一块堆内存中存放的值，它的生命周期是与当前程序有关的，想想读进程里变量肯定是比每次查询数据库快吧 就拿本地某个微服务的多个实例集群举例： 1234567Map &lt;category&gt; cache = new HashMap &lt;category&gt;();if (cache!=null){ return cache.get(&quot;data&quot;);}else{ cache.put(&quot;data&quot;); return cache.get(&quot;data&quot;);} 如果这么编写，搭配上面的图看问题很明显，本地缓存只能被本地进程访问，不能被其他程序访问。第一个实例中如果cache更新了，你是没办法通知到其他实例的，也没办法改变其他实例的cache这个本地变量，因为这个cache是与当前本地程序的生命周期有关，重启它变量存的值就没啦，并且因为是占用JAVA进程的JVM内存空间所以无法存放大量数据。 根据上面的分析总结本地缓存的弊端： 无法存放大量数据 集群之间数据更新不可见 数据会随应用重启丢失 四. 使用分布式缓存 这个比较好理解，数据不放在本地，而在其他服务器上大家都去那里读，修改，虽然网络传输没有直接访问本地快，但支持存储大量数据，不受重启影响，因为是共享一份数据(缓存)所以保证了数据一致性，解决了前面提到本地缓存的弊端。 【note 于2022/7/8更新】: 分布式缓存是独立部署的服务进程，并且和应用程序没有部署在同一台服务器上。所以是需要通过远程网络请求来完成分布式缓存的读写操作，并且分布式缓存主要应用在应用程序集群部署的环境下，解决了本地缓存的数据不一致问题。 五. 缓存带来的问题与锁缓存在面对并发时的问题。注意这里没特指是本地缓存还是分布式缓存，因为这是使用缓存本身固有的问题。 分布式场景下： 缓存穿透：缓存里没有，查数据的行文就是缓存穿透 如果来的请求是100万个，恰巧缓存中没有这个数据那怎么办？那100万次只能都走数据库查询了，那么这种针对同一个数据大量查询且有缓存穿透的行为，那就是缓存击穿了，怎么解决？返回null，使用布隆过滤器，这八股知识肯定都知道，面对多线程并发问题怎么解决也都知道，加锁呗，锁住排他让它们一个个做处理。 但是在实际项目中解决未必一定要像八股背的，具体事具体分析 解决缓存穿透 返回null值： 存在弊端，有多个缓存击穿的key时会存很多值为null的key容易造成内存压力，但是该项目中此场景中无需考虑有多个key的击穿情况，因为传过来的参数只有一个，且是固定的key，只考虑单key击穿即可。 使用布隆/布谷鸟过滤器，可以一定程度解决多key的击穿情况，在redis查询之前提前判断是否存在，但上面说过这个项目不用考虑。 本地缓存做一级缓存，分布式缓存做二级缓存，在一篇文章里看到的，目前还没时间尝试，等这里写完了再研究。 解决并发 首先我们加锁是为了解决并发带来的什么问题？ 1.解决发生故障时大量占用服务器和数据库连接造成的性能问题 2.多线程下数据修改读取不一致问题，那么是哪种数据不一致？通常： 多线程下堆内存变量不具有原子性的时候修改和读取造成的 (与场景无关) 解决：使用原子类，锁住修改数据的代码等等 由于时序性，消息传递不及时带来的数据不一致问题 (对应场景) tomcat虽然在请求处理上是nio但后续的工作线程还是bio的 ，所以要把放入缓存的步骤一起锁住，否则会出现加锁后依然会缓存穿透的现象。 六. 本地锁带来的问题我们锁住本地service对象 测试下本地锁是否生效 首先创建三个实例，然后保证Redis中没有catalog相关的数据 压力测试分别请求主页(一级分类)和另外的三级分类 查看各实例结果，发现对于并发带来的缓存击穿本地锁是生效的，都只查了一次数据库放入缓存后就走缓存查询了，但是问题来了，正常我们想要的是不论几个实例，都只查询一次数据库，那这查了四次肯定不对。（其实该项目中即使有10个实例走10次数据库查询影响也不是很大，就1000来条…） 分析下：既然Redis中已经有数据了，那其他实例读不到吗？是的读不到，因为100个请求在一秒内发送负载均衡到四个实例后第一次查询缓存的操作是在四个实例中同时执行的，这就是使用本地锁带来的弊端，只锁了自己，分布式场景下使用本地锁没办法互斥其他实例进程里的线程 查看日志发现，四个实例查询db的时间几乎相同，差别是在毫秒级别这远远不够一次远程请求redis查缓存的时间，所以根本观察不到Redis中已经有数据了。 123422:37:28.663 INFO 4756 --- [io-8090-exec-27] c.c.p.service.impl.CategoryServiceImpl 22:37:28.634 INFO 24116 --- [nio-8091-exec-1] c.c.p.service.impl.CategoryServiceImpl 22:37:28.652 INFO 21456 --- [io-8092-exec-26] c.c.p.service.impl.CategoryServiceImpl 22:37:28.646 INFO 3644 --- [io-8093-exec-26] c.c.p.service.impl.CategoryServiceImpl 观察上面日志还会发现个有趣的现象就是nio和io(bio)，这个点已经两次提到了，因为比较感兴趣知识量又不小所以关于了解nio与bio和探讨WebFlux响应式框架的容器(Netty)等扩展知识会在另一篇文章写到 下面这张图一眼就能出来的在分布式情况下使用本地锁带来的弊端，只锁住了自己对本地线程是排他的，但没有锁住其他实例的线程，那么我们想要的是无论是哪个实例，面对查询缓存这个操作就必须是排他的只允许一个线程访问。（埋个坑：其实读的时候也不一定只允许一个线程访问） 七.使用分布式锁那么加锁时机就要放在查询缓存这一过程上，结合上面的场景在这个项目中要怎么编写和使用分布式锁？ 可以看到锁住的资源不再是本地的，而是大家抢占远端的资源(Redis中的某一个key) 利用Redis中 setNX命令的特性设置一个key作为各实例的抢夺资源，再加锁从而保证了所有实例中线程的排他性 但在加锁（存key设置延时）,解锁（删key）的过程中要保证原子操作否则会出现死锁，在文档中写道我们可以配合Lua脚本来删除锁。 使用Redisson做分布式锁 Redisson封装了redis的操作加锁、解锁、执行lua脚本等等，原理和上面的一样，使用起来也和JUC包下工具相同。 项目商品服务测试，发现各实例只要一次查询操作 分析： 当我们访问首页时频繁的读分类数据，而这个数据几乎不会修改，那么把读操作也锁了那太可惜了，所以可以试试细分锁的粒度，当缓存中没有数据时我们用写锁锁住互斥其他读、写的线程，当缓存中有数据时用读锁锁住支持并发读。 这里是视频没有用到的方法我试了下QWQ，相同的线程组执行完看数据确实要优于之前的 测试数据 八. 缓存的最终数据一致性上面不断强调的数据一致性都是考虑代码执行异常时的情况，当我们后台人为修改时如何保证一致性？ 有双写，失效两种方式，这里的场景不是频繁修改所以失效方式更合理 结合Spring Cache的缓冲区特性，当更新操作触发时删除缓存中缓冲区中的数据。 有个注意的点：同样是视频没有讲的，在使用@CacheEvict清除缓冲区时，如果@Transactional事务加的不合理那么会出现数据不一致问题，原因是因为AOP执行顺序的原因 是先清除缓存，然后提交事务的，而我们是希望先提交事务，然后再更新缓存，参考阿里巴巴JAVA开发手册中提到的缓存回滚。这个案例网上有感兴趣可以查查。","link":"/2022/07/05/%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"}],"tags":[{"name":"开发技巧","slug":"开发技巧","link":"/tags/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"},{"name":"微服务","slug":"微服务","link":"/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"categories":[{"name":"开发技巧","slug":"开发技巧","link":"/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"},{"name":"微服务","slug":"微服务","link":"/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}]}