{"pages":[{"title":"tags","text":"","link":"/tags/index.html"},{"title":"overview","text":"与掘金发的文章不同的是，这里会记录学习历程，以及更多思考 未必像参照官方文档而写下的实践笔记一样准确 开发技巧养成良好的编码习惯 微服务 Microservices 响应式编程 Spring Boot WebFlux 容器化与云原生闲暇之余的探索 docker，k8s，以及Quarkus","link":"/overview/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/05/01/hello-world/"},{"title":"Oauth2.0社交化登录","text":"视频里用的是微博开放平台的接口，不知道为啥我设置的微博引导链接的回调地址一直不生效，所以这里我用的github，事实上还是微博符合场景，毕竟谁登录商城用github呢。 该项目下的场景大概思路是，用一个social_id(社交平台的账户ID)作为标识，当用户第三方登录时根据social_id判断是否已经在我们的应用里注册过了，注册过那么就是登录行为更新他的token，没注册过就给他注册一个新账户，下面主要说说第三方登录的一些编写细节。 使用流程参考文档： 识别和授权 GitHub 应用程序用户 - GitHub Docs 授权 OAuth 应用程序 - GitHub Docs 其他平台登录的流程也是这样 其实也没啥好写的。。。文档写的挺全照着写就行 抓重点写几个关键的地方 token过期时间官方文档写Oauth2方式返回access_token时是没有带过期时间的。。。 但关系不大甚至更简单了，看了下github默认token过期时间是28800(8小时)，反正这数是固定的，且每拿着code去请求access_token的时候，都会生成新的token和过期时间，所以在存token的时候跟着把这个数跟着一起存进去就行了 解析JSON 返回的JSON非常tmd长，2000多行，是个嵌套的json，主要是拿出这一部分。 根据这个结构，思路是先转成数组然后再把数组第1个元素转成对象。 访问慢咋办这个HttpUtils不是我自己封装的hh，是微博api文档里指向的一个github仓库里的。改造下，发http请求的时候给他挂上梯子(代理） 确实比之前快了些，登录的时候我看梯子那边也有上下行数据传输，但还是没有weibo快。 代码关键部分开头说的登录注册捏在一块写的逻辑service的部分代码 然后auth服务调用member的这个接口 最后效果 配合Spring Session放大session作用域，让其他服务也能知道登录的用户信息。","link":"/2022/07/09/Oauth2-0%E7%A4%BE%E4%BA%A4%E5%8C%96%E7%99%BB%E5%BD%95/"},{"title":"NIO和多路复用","text":"大概思路是这样，首先了解IO是什么？（输入输出），执行IO的过程（等待就绪之后数据从内核写入用户空间），那内核缓冲区，内核空间，用户空间是什么？（延伸出两个状态），而阻塞和非阻塞的问题就发生在（用户空间想要读取内核数据这期间）， I/O的知识分类： 内存IO 磁盘IO 网络IO 常见分类如上，关于文件I/O查了下属于低级的磁盘I/O所以就不另写了。IO顾名思义输入输出，更加抽象的表示是读和写的操作。 IO的过程分为两个阶段： 等待就绪：等待数据就绪，一般是将数据加载到内核缓冲区中，因为用户进程无法直接调用系统级资源，所以程序能处理的数据都是要先加载到内核 数据读写：用户空间里的进程想要执行IO操作读取数据，数据从内核写入到用户空间 要理解内核缓冲区和用户缓冲区的概念，首先要知道下内核态和用户态 内核态和用户态先来回顾下内核态和用户态： 众所周知，CPU 上会运行两种程序，一种是操作系统的内核程序（也称为系统程序），一种是应用程序。前者完成系统任务，后者实现应用任务。两者之间有控制和被控制的关系，前者有权管理和分配资源，而后者只能向系统申请使用资源。 显然，我们应该把在 CPU 上运行的这两类程序加以区分，这就是内核态和用户态出现的原因。 内核态（kernel mode）：当 CPU 处于内核态时，这是操作系统管理程序（也就是内核）运行时所处的状态。运行在内核态的程序可以访问计算机的任何资源，不受限制，为所欲为，例如协调 CPU 资源，分配内存资源，提供稳定的环境供应用程序运行等。 用户态（user mode）：应用程序基本都是运行在用户态的，或者说用户态就是提供应用程序运行的空间。运行在用户态的程序只能访问当前 CPU 上执行程序所在的地址空间，这样有效地防止了操作系统程序受到应用程序的侵害。 操作系统（内核）先从磁盘上读取数据存到内核空间，再把数据从内核空间拷贝到用户空间。此后，用户应用程序才可以操作此数据。 所以，在这个过程中有两次数据读取操作： 第一步：从磁盘上读取 第二步：从内存中读取 众所周知，访问磁盘的速度要远远低于访问内存的速度，完全不是一个量级的，所以理论上 read 磁盘的速度要远远慢于 read 内存。 那么整个文件读取过程的最大时间瓶颈就出现在了对磁盘的读取上。 要解决这个问题，内核缓冲区（Kernel Buffer Cache）就应运而生了。 本质上其实就是内核空间的一块内存区域 从 Buffer Cache（缓冲区缓存）这个名字上能看出来，内核缓冲区（准确的说，应该是内核缓冲区缓存），其实有两个作用，缓冲(Buffer) + 缓存(Cache) 如上图的buffer/cache中buffer指“buffer cache”，关于cache是什么没了解过 所以一个大概的流程是 而要讨论的阻塞问题就是发生在（2）（3）过程 同步阻塞在读写数据过程中会发生阻塞现象。当用户线程发出I/O请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才会解除block状态。 同步非阻塞 应用进程一直轮训调用recv()查看内核缓冲区的数据是否准备好，内核立即给予答复，如果回复结果通知数据还未准备好，则接着轮训进行询问。缺点：当进程有1000fds,代表用户进程轮询发生系统调用1000次kernel，来回的用户态和内核态的切换，成本几何上升。 I/O多路复用- IO multiplexing 单个线程就可以同时处理多个网络连接。内核负责轮询所有socket，当某个socket有数据到达了，就通知用户进程。多路复用在Linux内核代码迭代过程中依次支持了三种调用，即SELECT、POLL、EPOLL三种多路复用的网络I/O模型。","link":"/2022/07/22/NIO%E5%92%8C%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"},{"title":"在WSL2中使用Docker快速搭建Windows开发环境","text":"每次电脑重置之后最烦的就是搭建环境，什么mysql，redis，nacos等等，（当然现在我的nacos集群已经迁移的远程服务器上了qwq），要去各种官网下载安装包或者二进制文件，安装的时候勾选一个不慎就出问题，那是相当的麻烦，大三下学期结束又一次重置之后，果断选择在WSL2中使用docker，把上述环境全部作为容器run起来 只需pull下镜像，然后运行容器即可，免去上述的问题，并且不用时可以stop容器以减少内存占用 大概思路因为我当时刚装完系统没下picgo，所以也没截图什么的，只能说下当时的流程和最后结果 WSL2 现在微软已经把WSL2作为默认的了，我记的以前使用WSL2要去下扩展然后从WSL1切换过去，但现在很方便，按照文档指示就一条命令 地址 安装 WSL | Microsoft Docs 安装好之后去微软商店里下载Linux，wsl访问Linux目录的命令是\\\\wsl$ 安装docker推荐去b站看这个，以及他这个系列的其他视频 https://www.bilibili.com/video/BV1nt4y1k7Fy?share_source=copy_web 他会手把手教你如何在wsl管理的Linux中安装docker，以及如何抛弃vim并配置vscode在windows编写，Linux编译的高效操作。 容器化部署如果你对docker的概念以及常见使用方法不熟悉，可以去看这个 https://yeasy.gitbook.io/docker_practice/ 写的非常好，是一个开源的项目，一些大佬一起维护这本Gitbook 知道如何拉取镜像，部署容器，挂载目录，操作容器等等这些基本操作就够，当然你也可以编写自己的docker file为下一次重置做准备 (=W=) 管理容器可以设置开机时docker自启，这样随着docker服务的启动，是restart=always的容器也会跟着自己start起来。 WSL2中安装docker 并开机启动 - 简书 推荐使用portainer去管理容器","link":"/2022/06/16/%E5%9C%A8WSL%E4%B8%AD%E4%BD%BF%E7%94%A8Docker%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAWindows%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"title":"后端标准返回格式","text":"在前后端分离项目中，我们在后端把结果封装成JSON，然后前端拿到后进行解析填充到UI组件 这个JSON的格式，必须包含的三部分 status 状态值：由后端统一定义各种返回结果的状态码 message 描述：本次接口调用的结果描述 data 数据：本次返回的数据 12345{ &quot;status&quot;:&quot;200&quot;, &quot;message&quot;:&quot;操作成功&quot;, &quot;data&quot;:&quot;fuck!&quot;} 通常我们会在Common公共模块下的utils包中编写一个ResultData工具类，然后在Controller中使用ResultData的方法来封装结果，像这样： 定义返回结果对象123456789101112131415161718192021222324252627282930@Datapublic class ResultData&lt;T&gt; { // 结果状态 ,具体状态码见ReturnCode.java private int status; private String message; private T data; private long timestamp ; //接口调用时间戳 public ResultData (){ this.timestamp = System.currentTimeMillis(); } public static &lt;T&gt; ResultData&lt;T&gt; success(T data) { ResultData&lt;T&gt; resultData = new ResultData&lt;&gt;(); resultData.setStatus(ReturnCode.RC100.getCode()); resultData.setMessage(ReturnCode.RC100.getMessage()); resultData.setData(data); return resultData; } public static &lt;T&gt; ResultData&lt;T&gt; fail(int code, String message) { ResultData&lt;T&gt; resultData = new ResultData&lt;&gt;(); resultData.setStatus(code); resultData.setMessage(message); return resultData; }} 定义状态码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public enum ReturnCode { /**操作成功**/ RC100(100,&quot;操作成功&quot;), /**操作失败**/ RC999(999,&quot;操作失败&quot;), /**服务限流**/ RC200(200,&quot;服务开启限流保护,请稍后再试!&quot;), /**服务降级**/ RC201(201,&quot;服务开启降级保护,请稍后再试!&quot;), /**热点参数限流**/ RC202(202,&quot;热点参数限流,请稍后再试!&quot;), /**系统规则不满足**/ RC203(203,&quot;系统规则不满足要求,请稍后再试!&quot;), /**授权规则不通过**/ RC204(204,&quot;授权规则不通过,请稍后再试!&quot;), /**access_denied**/ RC403(403,&quot;无访问权限,请联系管理员授予权限&quot;), /**access_denied**/ RC401(401,&quot;匿名用户访问无权限资源时的异常&quot;), /**服务异常**/ RC500(500,&quot;系统异常，请稍后重试&quot;), INVALID_TOKEN(2001,&quot;访问令牌不合法&quot;), ACCESS_DENIED(2003,&quot;没有权限访问该资源&quot;), CLIENT_AUTHENTICATION_FAILED(1001,&quot;客户端认证失败&quot;), USERNAME_OR_PASSWORD_ERROR(1002,&quot;用户名或密码错误&quot;), UNSUPPORTED_GRANT_TYPE(1003, &quot;不支持的认证模式&quot;); /**自定义状态码**/ private final int code; /**自定义描述**/ private final String message; ReturnCode(int code, String message){ this.code = code; this.message = message; } public int getCode() { return code; } public String getMessage() { return message; }} 使用统一返回格式1234@GetMapping(&quot;/fuck&quot;)public ResultData&lt;String&gt; getFuck(){ return ResultData.success(&quot;fuck!&quot;);} 结果 1234567{ &quot;status&quot;: 100, &quot;message&quot;: &quot;fuck&quot;, &quot;data&quot;: null, &quot;timestamp&quot;: 1625736481648, &quot;httpStatus&quot;: 0} 更优雅每次都要ResultData.success()包装，直到后来我看在艿艿的公众号上看到了这种做法 借助SpringBoot提供的 ResponseBodyAdvice和@RestControllerAdvice ResponseBodyAdvice的作用： 拦截Controller方法的返回值，统一处理返回值/响应体，一般用来统一返回格式，加解密，签名等等 而@RestControllerAdvice是 @RestController注解的增强，可以实现三个方面的功能 全局异常处理 全局数据绑定 全局数据预处理 编写ResponseBodyAdvice的一个具体实现类ResponseBodyAdvic.java 123456789101112131415161718192021@RestControllerAdvicepublic class ResponseAdvice implements ResponseBodyAdvice&lt;Object&gt; { @Autowired private ObjectMapper objectMapper; @Override public boolean supports(MethodParameter methodParameter, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass) { return true; }@SneakyThrows@Overridepublic Object beforeBodyWrite(Object o, MethodParameter methodParameter, MediaType mediaType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass, ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse) { if(o instanceof String){ return objectMapper.writeValueAsString(ResultData.success(o)); } if(o instanceof ResultData){ return o; } return ResultData.success(o); }} 全局异常处理器面对错误结果抛出异常时，统一处理response的结果 12345678910111213141516 @Slf4j @RestControllerAdvicepublic class RestExceptionHandler { /** * 默认全局异常处理。 * @param e the e * @return ResultData */ @ExceptionHandler(Exception.class) @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) public ResultData&lt;String&gt; exception(Exception e) { log.error(&quot;全局异常信息 ex={}&quot;, e.getMessage(), e); return ResultData.fail(ReturnCode.RC500.getCode(),e.getMessage()); }}","link":"/2022/06/16/%E5%90%8E%E7%AB%AF%E6%A0%87%E5%87%86%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F/"},{"title":"实际项目中的缓存与锁","text":"结合当项目的场景思考与分析，右侧的目录是最好的思路和大纲 这个项目的场景使用Spring Cache配合本地锁是完全够用的，需要放入缓存的数据也就千条即使走db查询性能也可以忽略不计，所以本着学习的目的来探讨分布式场景下的问题和方案。 下面的知识点，代码，方案实现并不完全来源于视频，比如精细了锁的粒度用读写锁，缓存的事务回滚如何避免出现bug，分析看门狗机制等等都是视频没有提到的。 一. 适合放入缓存的数据 及时性，对数据短暂的一致性要求不高的 访问量大且更新频率不高的数据 (读多写少) 举例： 电商类应用，商品分类，商品列表等适合缓存并加一个失效时间（根据数据更新频率来定） 后台如果发布一个商品，买家需要5分钟才能看到新的商品一般还是可以接受的 物流信息 在该项目中商城的首页分类信息(1452条)几乎是不总修改的，但是频繁读取所以适合放入缓存中 由于无法在多台服务器上搭建真正的分布式系统，所以只能创建多个实例来模拟伪分布式的情况，实际上分布式与伪分布式需要被考虑和被解决的问题是一样的。 二. 使用缓存的流程以下的使用缓存的各种方案都是基于该思路流程 三. 本地缓存的局限性前面提到使用缓存是为了提高读取速度 那么使用本地缓存可以理解为，使用一个进程里的某一块堆内存中存放的值，它的生命周期是与当前程序有关的，想想读进程里变量肯定是比每次查询数据库快吧 就拿本地某个微服务的多个实例集群举例： 1234567Map &lt;category&gt; cache = new HashMap &lt;category&gt;();if (cache!=null){ return cache.get(&quot;data&quot;);}else{ cache.put(&quot;data&quot;); return cache.get(&quot;data&quot;);} 如果这么编写，搭配上面的图看问题很明显，本地缓存只能被本地进程访问，不能被其他程序访问。第一个实例中如果cache更新了，你是没办法通知到其他实例的，也没办法改变其他实例的cache这个本地变量，因为这个cache是与当前本地程序的生命周期有关，重启它变量存的值就没啦，并且因为是占用JAVA进程的JVM内存空间所以无法存放大量数据。 根据上面的分析总结本地缓存的弊端： 无法存放大量数据 集群之间数据更新不可见 数据会随应用重启丢失 四. 使用分布式缓存 这个比较好理解，数据不放在本地，而在其他服务器上大家都去那里读，修改，虽然网络传输没有直接访问本地快，但支持存储大量数据，不受重启影响，因为是共享一份数据(缓存)所以保证了数据一致性，解决了前面提到本地缓存的弊端。 【note 于2022/7/8更新】: 分布式缓存是独立部署的服务进程，并且和应用程序没有部署在同一台服务器上。所以是需要通过远程网络请求来完成分布式缓存的读写操作，并且分布式缓存主要应用在应用程序集群部署的环境下，解决了本地缓存的数据不一致问题。 五. 并发下缓存带来的问题与锁缓存在面对并发时的问题。注意这里没特指是本地缓存还是分布式缓存，因为这是使用缓存本身固有的问题。 分布式场景下： 缓存穿透：缓存里没有，查持久层查询的行为就是缓存穿透，这里的持久层是谁没有特指，Redis本身的持久化或数据库都算在范围内。 如果来的请求是100万个，恰巧缓存中没有这个数据那怎么办？那100万次只能都走数据库查询了，那么这种针对同一个数据大量查询且有缓存穿透的行为，那就是缓存击穿了，怎么解决？返回null，使用布隆过滤器，这八股知识肯定都知道，面对多线程并发问题怎么解决也都知道，加锁呗，锁住排他让它们一个个做处理。 但是在实际项目中解决未必一定要像八股背的，具体事具体分析 解决缓存穿透 返回null值： 存在弊端，有多个缓存击穿的key时会存很多值为null的key容易造成内存压力，但是该项目中此场景中无需考虑有多个key的击穿情况，因为传过来的参数只有一个，且是固定的key，只考虑单key击穿即可。 使用布隆/布谷鸟过滤器，可以一定程度解决多key的击穿情况，在redis查询之前提前判断是否存在，但上面说过这个项目不用考虑。 本地缓存做一级缓存，分布式缓存做二级缓存，在一篇文章里看到的，目前还没时间尝试，等这里写完了再研究。 解决并发 首先我们加锁是为了解决并发带来的什么问题？ 1.解决发生故障时大量占用服务器和数据库连接造成的性能问题 2.多线程下数据修改读取不一致问题，那么是哪种数据不一致？通常： 多线程下堆内存变量不具有原子性的时候修改和读取造成的 (与场景无关) 解决：使用原子类，锁住修改数据的代码，禁止JVM优化指令重排等等 由于时序性，消息传递不及时带来的数据不一致问题 (对应场景) tomcat虽然在请求处理上是nio但后续的工作线程还是bio ，所以要把放入缓存的步骤一起锁住，否则会出现加锁后依然会缓存穿透的现象。 六. 使用本地锁的优劣我们锁住本地service对象 测试下本地锁是否生效 首先创建三个实例，然后保证Redis中没有catalog相关的数据 压力测试分别请求主页(一级分类)和另外的三级分类 查看各实例结果，发现对于并发带来的缓存击穿本地锁是生效的，都只查了一次数据库放入缓存后就走缓存查询了，但是问题来了，正常我们想要的是不论几个实例，都只查询一次数据库，那这查了四次肯定不对。（其实该项目中即使有10个实例走10次数据库查询影响也不是很大，就1000来条…） 分析下：既然Redis中已经有数据了，那其他实例读不到吗？是的读不到，因为100个请求在一秒内发送负载均衡到四个实例后第一次查询缓存的操作是在四个实例中同时执行的，这就是使用本地锁带来的弊端，只锁了自己，分布式场景下使用本地锁没办法互斥其他实例进程里的线程 查看日志发现，四个实例查询db的时间几乎相同，差别是在毫秒级别这远远不够一次远程请求redis查缓存的时间，所以根本观察不到Redis中已经有数据了。 123422:37:28.663 INFO 4756 --- [io-8090-exec-27] c.c.p.service.impl.CategoryServiceImpl 22:37:28.634 INFO 24116 --- [nio-8091-exec-1] c.c.p.service.impl.CategoryServiceImpl 22:37:28.652 INFO 21456 --- [io-8092-exec-26] c.c.p.service.impl.CategoryServiceImpl 22:37:28.646 INFO 3644 --- [io-8093-exec-26] c.c.p.service.impl.CategoryServiceImpl 观察上面日志还会发现个有趣的现象就是nio和io(bio)，这个点已经两次提到了，因为比较感兴趣知识量又不小所以关于了解nio与bio和探讨WebFlux响应式框架的容器(Netty)等扩展知识会在另一篇文章写到 下面这张图一眼就能出来的在分布式情况下使用本地锁带来的弊端，只锁住了自己对本地线程是排他的，但没有锁住其他实例的线程，那么我们想要的是无论是哪个实例，面对查询缓存这个操作就必须是排他的只允许一个线程访问。（埋个坑：其实读的时候也不一定只允许一个线程访问） 七.理想的使用分布式锁那么加锁时机就要放在查询缓存这一过程上，结合上面的场景在这个项目中要怎么编写和使用分布式锁？ 可以看到锁住的资源不再是本地的，而是大家抢占远端的资源(Redis中的某一个key) 利用Redis中 setNX命令的特性设置一个key作为各实例的抢夺资源，再加锁从而保证了所有实例中线程的排他性 但在加锁（存key设置延时）,解锁（删key）的过程中要保证原子操作否则会出现死锁，在文档中写道我们可以配合Lua脚本来删除锁。 使用Redisson做分布式锁 Redisson封装了redis的操作加锁、解锁、执行lua脚本等等，原理和上面的一样，使用起来也和JUC包下工具相同。 项目商品服务测试，发现各实例只要一次查询操作 分析： 当我们访问首页时频繁的读分类数据，而这个数据几乎不会修改，那么把读操作也锁了那太可惜了，所以可以试试细分锁的粒度，当缓存中没有数据时我们用写锁锁住互斥其他读、写的线程，当缓存中有数据时用读锁锁住支持并发读。 这里是视频没有用到的方法我试了下QWQ，相同的线程组执行完看数据确实要优于之前的 测试数据 八. 缓存的最终数据一致性上面不断强调的数据一致性都是考虑代码执行异常时的情况，当我们后台人为修改时如何保证一致性？ 有双写，失效两种方式，这里的场景不是频繁修改所以失效方式更合理 结合Spring Cache的缓冲区特性，当更新操作触发时删除缓存中缓冲区中的数据。 有个注意的点：同样是视频没有讲的，在使用@CacheEvict清除缓冲区时，如果@Transactional事务加的不合理那么会出现数据不一致问题，原因是因为AOP执行顺序的原因 是先清除缓存，然后提交事务的，而我们是希望先提交事务，然后再更新缓存，参考阿里巴巴JAVA开发手册中提到的缓存回滚。这个案例网上有感兴趣可以查查。","link":"/2022/07/05/%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"},{"title":"快速上手React","text":"react和vue的虚拟dom都是一样的， 都是用JS对象来模拟真实DOM。 为什么选React： 函数式编码风格和后端相似 Kotlin有 “kotlin react native”，可以用Kotlin替代JS写React 记不住的ES6React 如何使用 ES6 (w3schools.cn) 渲染和vue里绑定一个id叫app的标签容器一样，在react中用createRoot获取这个容器，然后可以往里填充HTML代码 demo 1const root = ReactDOM.createRoot(document.getElementById('root')); React JSXJSX: JavaScript XML JSX 允许我们在 React 中编写 HTML 规范需要渲染的HTML必须包含在一个顶级元素里 例如 12345678910111213错误const demo = ( &lt;div&gt; &lt;p&gt; fuck &lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt; you &lt;/p&gt; &lt;/div&gt;)正确写法const demo = (&lt;div&gt; &lt;div&gt; &lt;p&gt; fuck &lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt; you &lt;/p&gt; &lt;/div&gt;&lt;/div&gt;) demo1 123const myElement = &lt;h1&gt; {5 + 5} fuck you&lt;/h1&gt;;const root = ReactDOM.createRoot(document.getElementById('root'));root.render(myElement); demo2 1const myElement = React.createElement('h1', { className: &quot;fuck&quot; }, 'I do not use JSX!'); 保留Class属性1const myFirstElement = &lt;h1 class=&quot;cao&quot;&gt; fuck &lt;/h1&gt; 表达式demo 123456789101112131415161718192021const x = 5;const y = 1;let text = &quot;&quot;;x &gt; 1 ? text = &quot;fuck you&quot; : text = &quot;you fuck&quot;;const myFirstElement = ( &lt;h1 class=&quot;cao&quot;&gt; Hello React! {text} {(x)&gt;0 ? (text)=&quot;love you&quot;:(text)=&quot;you love&quot;} &lt;/h1&gt;)const root = ReactDOM.createRoot(document.getElementById('root'));root.render(myFirstElement);Element); 组件规范：组件名必须大写 123456789101112131415161718//demo1class Car extends React.Component { render(){ return (&lt;p&gt; hello car&lt;/p&gt;); }}//demo2function Cars (){ return &lt;p&gt; hello cars&lt;/p&gt;;}//渲染const root = ReactDOM.createRoot(document.getElementById('root'));root.render(&lt;Car/&gt;); 传参1234567891011//demo1class Car extends React.Component { render(){ return (&lt;p&gt; hello {this.props.color} car&lt;/p&gt;); }}//demo2function Cars (props){ return &lt;p&gt; hello {props.color} cars &lt;/p&gt;;} 组件之间传参 1234567891011121314151617function Car(props) { return &lt;h2&gt;I am a { props.brand }!&lt;/h2&gt;;}function Garage() { //局部变量 const carName = &quot;Ford&quot;; return ( &lt;&gt; &lt;h1&gt;Who lives in my garage?&lt;/h1&gt; &lt;Car brand={ carName } /&gt; &lt;/&gt; );}const root = ReactDOM.createRoot(document.getElementById('root'));root.render(&lt;Garage /&gt;); 传对象12345678910111213141516171819import React from 'react';import ReactDOM from 'react-dom/client';function Car(props) { return &lt;h2&gt;I am a { props.brand.model }!&lt;/h2&gt;;}function Garage() { const carInfo = { name: &quot;Ford&quot;, model: &quot;Mustang&quot; }; return ( &lt;&gt; &lt;h1&gt;Who lives in my garage?&lt;/h1&gt; &lt;Car brand={ carInfo } /&gt; &lt;/&gt; );}const root = ReactDOM.createRoot(document.getElementById('root'));root.render(&lt;Garage /&gt;); 组件嵌套12345678910111213141516class Car extends React.Component { render() { return (&lt;p&gt; hello {this.props.color} car&lt;/p&gt;); }}function Cars(props) { return ( &lt;&gt; &lt;p&gt; hello {props.color} cars &lt;/p&gt; &lt;Car color=&quot;fuck&quot;&gt;&lt;/Car&gt; &lt;/&gt; );} 引入组件12345678910111213function Person (props){ return ( &lt;&gt; &lt;p&gt;this is {props.attr} person&lt;/p&gt; &lt;/&gt; );}export default Person; import Person from './componet/Person'; 事件React中事件语法 onClick={func} demo 12345678910function Fuck(){ const shoot = (a) =&gt;{ alert(&quot;hi guys&quot;) } return ( &lt;button onClick={shoot}&gt;task me!&lt;/button&gt; )} 传参 123456789101112131415161718function Fuck(){ const shoot = (a) =&gt;{ alert(a) } return ( // modify &lt;button onClick={()=&gt; shoot(&quot;hi guys&quot;)}&gt;task me!&lt;/button&gt; )}const myElement = React.createElement('h1', { className: &quot;fuck&quot; }, 'I use JSX!');const root = ReactDOM.createRoot(document.getElementById('root'));root.render(&lt;Fuck&gt;&lt;/Fuck&gt;);","link":"/2022/07/26/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BReact/"}],"tags":[{"name":"开发技巧","slug":"开发技巧","link":"/tags/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"}],"categories":[{"name":"开发技巧","slug":"开发技巧","link":"/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"},{"name":"工作效率","slug":"工作效率","link":"/categories/%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87/"},{"name":"分布式","slug":"分布式","link":"/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"}]}