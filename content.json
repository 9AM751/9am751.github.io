{"pages":[{"title":"Leetcode数组题","text":"数组概念最基础的数据结构 [note] 为什么访问是O(1)？ 因为数组的特性内存地址连续，无论是根据下标索引还是根据内存地址计算都可以直接访问到第K个元素，而不像搜索，插入，删除一样与遍历个数有关 特点 适合读多写少的情况 力扣485485. 最大连续 1 的个数 就是考察数组的用法， 思路： 从头遍历遇见1计数器就+1，初始化一个最大值max，遇见0时当前计数器值和max作比较然后大的保存在 max中，计数器重置为0，最后返回的是max值 力扣283283. 移动零 这个题很有意思，看起来非常简单，但值得思考的有很多 我大概写了三个版本，第一和第三是自己写的，第二是看题解(左右指针) 一. 看到这个题要求末尾都是0，我当时脑子里第一反应就是数组从末尾看，像冒泡排序一样，遇见0就交换，但是没实现好数组越界了QWQ，并且这也不是个聪明方法 二. 第二回我去看的题解，双指针，右指针遍历，遇见不为0的就赋给左指针，然后双指针再移动，最后把左指针的右侧置为0就可以了 三. 当然如果你讨厌左右的概念这样更直观些，这个是在大姐头哪里学的，那么代码可以拆开这样写 力扣27 27. 移除元素 和上面一样的解法 头尾双指针的解法 和之前的快慢双指针不同，这次可以用头尾双指针 L指针找到val停下 R指针找不到val停下 最后判断左右指针共同的当前位置是否为val 如果不是那么 长度得+1，因为数组是从0起始的","link":"/Leetcode%E6%95%B0%E7%BB%84%E9%A2%98.html"},{"title":"链表题","text":"203. 移除链表元素和官方题解不同，没有直接操作pre节点 206. 反转链表拆来拆去，再连上，感觉没什么意思，直接存栈里然后再拿出来不就反转了吗。。。","link":"/%E9%93%BE%E8%A1%A8%E9%A2%98.html"},{"title":"overview","text":"与掘金发的文章不同的是，这里会记录学习历程，以及更多思考，未必像参照官方文档而写下的实践笔记一样准确。 开发技巧养成良好的编码习惯 微服务 Microservices 响应式编程 Spring Boot WebFlux 容器化与云原生闲暇之余的探索 docker，k8s，以及Quarkus","link":"/overview/index.html"},{"title":"算法复杂度","text":"花十分钟回顾下，因为懒得开Idea写java的demo，所以用python比较简洁看起来像伪代码","link":"/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/06/16/hello-world/"},{"title":"后端标准返回格式","text":"在前后端分离项目中，我们在后端把结果封装成JSON，然后前端拿到后进行解析填充到UI组件 这个JSON的格式，必须包含的三部分 status 状态值：由后端统一定义各种返回结果的状态码 message 描述：本次接口调用的结果描述 data 数据：本次返回的数据 12345{ &quot;status&quot;:&quot;200&quot;, &quot;message&quot;:&quot;操作成功&quot;, &quot;data&quot;:&quot;fuck!&quot;} 通常我们会在Common公共模块下的utils包中编写一个ResultData工具类，然后在Controller中使用ResultData的方法来封装结果，像这样： 定义返回结果对象123456789101112131415161718192021222324252627282930@Datapublic class ResultData&lt;T&gt; { // 结果状态 ,具体状态码见ReturnCode.java private int status; private String message; private T data; private long timestamp ; //接口调用时间戳 public ResultData (){ this.timestamp = System.currentTimeMillis(); } public static &lt;T&gt; ResultData&lt;T&gt; success(T data) { ResultData&lt;T&gt; resultData = new ResultData&lt;&gt;(); resultData.setStatus(ReturnCode.RC100.getCode()); resultData.setMessage(ReturnCode.RC100.getMessage()); resultData.setData(data); return resultData; } public static &lt;T&gt; ResultData&lt;T&gt; fail(int code, String message) { ResultData&lt;T&gt; resultData = new ResultData&lt;&gt;(); resultData.setStatus(code); resultData.setMessage(message); return resultData; }} 定义状态码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public enum ReturnCode { /**操作成功**/ RC100(100,&quot;操作成功&quot;), /**操作失败**/ RC999(999,&quot;操作失败&quot;), /**服务限流**/ RC200(200,&quot;服务开启限流保护,请稍后再试!&quot;), /**服务降级**/ RC201(201,&quot;服务开启降级保护,请稍后再试!&quot;), /**热点参数限流**/ RC202(202,&quot;热点参数限流,请稍后再试!&quot;), /**系统规则不满足**/ RC203(203,&quot;系统规则不满足要求,请稍后再试!&quot;), /**授权规则不通过**/ RC204(204,&quot;授权规则不通过,请稍后再试!&quot;), /**access_denied**/ RC403(403,&quot;无访问权限,请联系管理员授予权限&quot;), /**access_denied**/ RC401(401,&quot;匿名用户访问无权限资源时的异常&quot;), /**服务异常**/ RC500(500,&quot;系统异常，请稍后重试&quot;), INVALID_TOKEN(2001,&quot;访问令牌不合法&quot;), ACCESS_DENIED(2003,&quot;没有权限访问该资源&quot;), CLIENT_AUTHENTICATION_FAILED(1001,&quot;客户端认证失败&quot;), USERNAME_OR_PASSWORD_ERROR(1002,&quot;用户名或密码错误&quot;), UNSUPPORTED_GRANT_TYPE(1003, &quot;不支持的认证模式&quot;); /**自定义状态码**/ private final int code; /**自定义描述**/ private final String message; ReturnCode(int code, String message){ this.code = code; this.message = message; } public int getCode() { return code; } public String getMessage() { return message; }} 使用统一返回格式1234@GetMapping(&quot;/fuck&quot;)public ResultData&lt;String&gt; getFuck(){ return ResultData.success(&quot;fuck!&quot;);} 结果 1234567{ &quot;status&quot;: 100, &quot;message&quot;: &quot;fuck&quot;, &quot;data&quot;: null, &quot;timestamp&quot;: 1625736481648, &quot;httpStatus&quot;: 0} 更优雅每次都要ResultData.success()包装，直到后来我看在艿艿的公众号上看到了这种做法 借助SpringBoot提供的 ResponseBodyAdvice和@RestControllerAdvice ResponseBodyAdvice的作用： 拦截Controller方法的返回值，统一处理返回值/响应体，一般用来统一返回格式，加解密，签名等等 而@RestControllerAdvice是 @RestController注解的增强，可以实现三个方面的功能 全局异常处理 全局数据绑定 全局数据预处理 编写ResponseBodyAdvice的一个具体实现类ResponseBodyAdvic.java 123456789101112131415161718192021@RestControllerAdvicepublic class ResponseAdvice implements ResponseBodyAdvice&lt;Object&gt; { @Autowired private ObjectMapper objectMapper; @Override public boolean supports(MethodParameter methodParameter, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass) { return true; }@SneakyThrows@Overridepublic Object beforeBodyWrite(Object o, MethodParameter methodParameter, MediaType mediaType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass, ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse) { if(o instanceof String){ return objectMapper.writeValueAsString(ResultData.success(o)); } if(o instanceof ResultData){ return o; } return ResultData.success(o); }} 全局异常处理器面对错误结果抛出异常时，统一处理response的结果 12345678910111213141516 @Slf4j @RestControllerAdvicepublic class RestExceptionHandler { /** * 默认全局异常处理。 * @param e the e * @return ResultData */ @ExceptionHandler(Exception.class) @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) public ResultData&lt;String&gt; exception(Exception e) { log.error(&quot;全局异常信息 ex={}&quot;, e.getMessage(), e); return ResultData.fail(ReturnCode.RC500.getCode(),e.getMessage()); }}","link":"/2022/06/16/%E5%90%8E%E7%AB%AF%E6%A0%87%E5%87%86%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F/"},{"title":"在WSL2中使用Docker快速搭建Windows开发环境","text":"每次电脑重置之后最烦的就是搭建环境，什么mysql，redis，nacos等等，（当然现在我的nacos集群已经迁移的远程服务器上了qwq），要去各种官网下载安装包或者二进制文件，安装的时候勾选一个不慎就出问题，那是相当的麻烦，大三下学期结束又一次重置之后，果断选择在WSL2中使用docker，把上述环境全部作为容器run起来 只需pull下镜像，然后运行容器即可，免去上述的问题，并且不用时可以stop容器以减少内存占用 大概思路因为我当时刚装完系统没下picgo，所以也没截图什么的，只能说下当时的流程和最后结果 WSL2 现在微软已经把WSL2作为默认的了，我记的以前使用WSL2要去下扩展然后从WSL1切换过去，但现在很方便，按照文档指示就一条命令 地址 安装 WSL | Microsoft Docs 安装好之后去微软商店里下载Linux，wsl访问Linux目录的命令是\\\\wsl$ 安装docker推荐去b站看这个，以及他这个系列的其他视频 https://www.bilibili.com/video/BV1nt4y1k7Fy?share_source=copy_web 他会手把手教你如何在wsl管理的Linux中安装docker，以及如何抛弃vim并配置vscode在windows编写，Linux编译的高效操作。 容器化部署如果你对docker的概念以及常见使用方法不熟悉，可以去看这个 https://yeasy.gitbook.io/docker_practice/ 写的非常好，是一个开源的项目，一些大佬一起维护这本Gitbook 知道如何拉取镜像，部署容器，挂载目录，操作容器等等这些基本操作就够，当然你也可以编写自己的docker file为下一次重置做准备 (=W=) 管理容器可以设置开机时docker自启，这样随着docker服务的启动，是restart=always的容器也会跟着自己start起来。 WSL2中安装docker 并开机启动 - 简书 推荐使用portainer去管理容器","link":"/2022/06/16/%E5%9C%A8WSL%E4%B8%AD%E4%BD%BF%E7%94%A8Docker%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAWindows%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}],"tags":[{"name":"开发技巧","slug":"开发技巧","link":"/tags/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"}],"categories":[{"name":"开发技巧","slug":"开发技巧","link":"/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"}]}