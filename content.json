{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"overview","text":"包含以下内容 开发技巧养成良好的编码习惯 了解常见的代码规范 算法基础常见数据结构与算法回顾 以及Leetcode经典题目 微服务 Microservices 响应式编程 Spring Boot WebFlux 容器化与云原生闲暇之余的探索 docker，k8s，以及Quarkus","link":"/overview/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/06/16/hello-world/"},{"title":"后端标准返回格式","text":"在前后端分离项目中，我们在后端把结果封装成JSON，然后前端拿到后进行解析填充到UI组件 这个JSON的格式，必须包含的三部分 status 状态值：由后端统一定义各种返回结果的状态码 message 描述：本次接口调用的结果描述 data 数据：本次返回的数据 12345{ &quot;status&quot;:&quot;200&quot;, &quot;message&quot;:&quot;操作成功&quot;, &quot;data&quot;:&quot;fuck!&quot;} 通常我们会在Common公共模块下的utils包中编写一个ResultData工具类，然后在Controller中使用ResultData的方法来封装结果，像这样： 定义返回结果对象123456789101112131415161718192021222324252627282930@Datapublic class ResultData&lt;T&gt; { // 结果状态 ,具体状态码见ReturnCode.java private int status; private String message; private T data; private long timestamp ; //接口调用时间戳 public ResultData (){ this.timestamp = System.currentTimeMillis(); } public static &lt;T&gt; ResultData&lt;T&gt; success(T data) { ResultData&lt;T&gt; resultData = new ResultData&lt;&gt;(); resultData.setStatus(ReturnCode.RC100.getCode()); resultData.setMessage(ReturnCode.RC100.getMessage()); resultData.setData(data); return resultData; } public static &lt;T&gt; ResultData&lt;T&gt; fail(int code, String message) { ResultData&lt;T&gt; resultData = new ResultData&lt;&gt;(); resultData.setStatus(code); resultData.setMessage(message); return resultData; }} 定义状态码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public enum ReturnCode { /**操作成功**/ RC100(100,&quot;操作成功&quot;), /**操作失败**/ RC999(999,&quot;操作失败&quot;), /**服务限流**/ RC200(200,&quot;服务开启限流保护,请稍后再试!&quot;), /**服务降级**/ RC201(201,&quot;服务开启降级保护,请稍后再试!&quot;), /**热点参数限流**/ RC202(202,&quot;热点参数限流,请稍后再试!&quot;), /**系统规则不满足**/ RC203(203,&quot;系统规则不满足要求,请稍后再试!&quot;), /**授权规则不通过**/ RC204(204,&quot;授权规则不通过,请稍后再试!&quot;), /**access_denied**/ RC403(403,&quot;无访问权限,请联系管理员授予权限&quot;), /**access_denied**/ RC401(401,&quot;匿名用户访问无权限资源时的异常&quot;), /**服务异常**/ RC500(500,&quot;系统异常，请稍后重试&quot;), INVALID_TOKEN(2001,&quot;访问令牌不合法&quot;), ACCESS_DENIED(2003,&quot;没有权限访问该资源&quot;), CLIENT_AUTHENTICATION_FAILED(1001,&quot;客户端认证失败&quot;), USERNAME_OR_PASSWORD_ERROR(1002,&quot;用户名或密码错误&quot;), UNSUPPORTED_GRANT_TYPE(1003, &quot;不支持的认证模式&quot;); /**自定义状态码**/ private final int code; /**自定义描述**/ private final String message; ReturnCode(int code, String message){ this.code = code; this.message = message; } public int getCode() { return code; } public String getMessage() { return message; }} 使用统一返回格式1234@GetMapping(&quot;/fuck&quot;)public ResultData&lt;String&gt; getFuck(){ return ResultData.success(&quot;fuck!&quot;);} 结果 1234567{ &quot;status&quot;: 100, &quot;message&quot;: &quot;fuck&quot;, &quot;data&quot;: null, &quot;timestamp&quot;: 1625736481648, &quot;httpStatus&quot;: 0} 更优雅每次都要ResultData.success()包装，直到后来我看在艿艿的公众号上看到了这种做法 借助SpringBoot提供的 ResponseBodyAdvice和@RestControllerAdvice ResponseBodyAdvice的作用： 拦截Controller方法的返回值，统一处理返回值/响应体，一般用来统一返回格式，加解密，签名等等 而@RestControllerAdvice是 @RestController注解的增强，可以实现三个方面的功能 全局异常处理 全局数据绑定 全局数据预处理 编写ResponseBodyAdvice的一个具体实现类ResponseBodyAdvic.java 123456789101112131415161718192021@RestControllerAdvicepublic class ResponseAdvice implements ResponseBodyAdvice&lt;Object&gt; { @Autowired private ObjectMapper objectMapper; @Override public boolean supports(MethodParameter methodParameter, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass) { return true; }@SneakyThrows@Overridepublic Object beforeBodyWrite(Object o, MethodParameter methodParameter, MediaType mediaType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass, ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse) { if(o instanceof String){ return objectMapper.writeValueAsString(ResultData.success(o)); } if(o instanceof ResultData){ return o; } return ResultData.success(o); }} 全局异常处理器面对错误结果抛出异常时，统一处理response的结果 12345678910111213141516 @Slf4j @RestControllerAdvicepublic class RestExceptionHandler { /** * 默认全局异常处理。 * @param e the e * @return ResultData */ @ExceptionHandler(Exception.class) @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) public ResultData&lt;String&gt; exception(Exception e) { log.error(&quot;全局异常信息 ex={}&quot;, e.getMessage(), e); return ResultData.fail(ReturnCode.RC500.getCode(),e.getMessage()); }}","link":"/2022/06/16/%E5%90%8E%E7%AB%AF%E6%A0%87%E5%87%86%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F/"},{"title":"在WSL2中使用Docker快速搭建Windows开发环境","text":"每次电脑重置之后最烦的就是搭建环境，什么mysql，redis，nacos等等，（当然现在我的nacos集群已经迁移的远程服务器上了qwq），要去各种官网下载安装包或者二进制文件，安装的时候勾选一个不慎就出问题，那是相当的麻烦，大三下学期结束又一次重置之后，果断选择在WSL2中使用docker，把上述环境全部作为容器run起来 只需pull下镜像，然后运行容器即可，免去上述的问题，并且不用时可以stop容器以减少内存占用 大概思路因为我当时刚装完系统没下picgo，所以也没截图什么的，只能说下当时的流程和最后结果 WSL2 现在微软已经把WSL2作为默认的了，我记的以前使用WSL2要去下扩展然后从WSL1切换过去，但现在很方便，按照文档指示就一条命令 地址 安装 WSL | Microsoft Docs 安装好之后去微软商店里下载Linux，wsl访问Linux目录的命令是\\\\wsl$ 安装docker推荐去b站看这个，以及他这个系列的其他视频 https://www.bilibili.com/video/BV1nt4y1k7Fy?share_source=copy_web 他会手把手教你如何在wsl管理的Linux中安装docker，以及如何抛弃vim并配置vscode在windows编写，Linux编译的高效操作。 容器化部署如果你对docker的概念以及常见使用方法不熟悉，可以去看这个 https://yeasy.gitbook.io/docker_practice/ 写的非常好，是一个开源的项目，一些大佬一起维护这本Gitbook 知道如何拉取镜像，部署容器，挂载目录，操作容器等等这些基本操作就够，当然你也可以编写自己的docker file为下一次重置做准备 (=W=) 管理容器可以设置开机时docker自启，这样随着docker服务的启动，是restart=always的容器也会跟着自己start起来。 WSL2中安装docker 并开机启动 - 简书 推荐使用portainer去管理容器","link":"/2022/06/16/%E5%9C%A8WSL%E4%B8%AD%E4%BD%BF%E7%94%A8Docker%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAWindows%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}],"tags":[{"name":"开发技巧","slug":"开发技巧","link":"/tags/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"}],"categories":[{"name":"开发技巧","slug":"开发技巧","link":"/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"},{"name":"Common","slug":"开发技巧/Common","link":"/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/Common/"}]}